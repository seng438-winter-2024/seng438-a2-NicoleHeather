**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 â€“ Requirements-Based Test Generation**

| Group 23:       |     |
| ----------------|-----|
| Nicole Heather  |     |
| Jennifer Jay    |     |
| Nora Melik      |     |
| Nelson Thompson |     |

# 1 Introduction

In the world of software design and testing, there are many methods used to ensure correctness but also provide developers with an efficient way to produce large scale testing modules. One of the more common tools is JUnit, a java based software that excels in large projects, mass data input and automted procedures. This labs purpose is to explore the design, planning and excution of JUnit test cases in blackbox testing, and how they can give a glimpse into the issues of code that cannot even be seen by the tester. 

# 2 Detailed description of unit test strategy

The planning and design for this lab was all done as a group before any Junit tests were written, all members also have gone over the introduction and instructions in the handout as well as downloading eclipse and starting their own project. By splitting up into pairs, we faciliate pair programming while also being more efficient in our use of time. We assign each pair a leader that is responsible for the coding and making pull requests to github, while the other maintains quiality control and documents the process in the lab report. For the classes and their testing execution themselves, we split Utilities and Range into sections for each pair to complete. Our chosen functions are as follows: 

DataUtilities:
| Methods                                                            | Functons being Tested
|--------------------------------------------------------------------|-------------------------------------------
| caclulateColumnTotal(Values2D data, int column) : static double    | Correctness, throws excpetion when needed 
| calculateRowTotal(Values2D data, int row) : static double          | Correctness, throws excpetion when needed 
| createNumber(double[] data) : static java.lang.Numer[]             | Correctness, throws excpetion when needed 
| createNumberArray2D(double[][] data) : static java.lang.Number[][] | Correctness, throws excpetion when needed 
| getCumulativePercentages(KeyedValues data) : static KeyedValues    | Correctness, throws excpetion when needed 

Range:
| Methods                       | Functions Being Tested
|-------------------------------|--------------------------
| getCentralValue() : double    | Correctness, consistancy
| getLength() : double          | Correctness, consistancy 
| getLowerBound() : double      | Correctness, consistancy 
| getUpperBound() : double      | Correctness, consistancy
| toString() : java.lang.String | Correctness, consistancy 

Functionalities not being tested:
- Hardware interface
- Database logic
- Communication interface
- User interface and communication
- Security
- Performance

Why we are choosing these Methods:
- Range:
   - These functions are relativley simple but they are also the building blocks of many other methods and classes as they provide access to private data members. They can also provide avenues to test setters and constructors, so if they are inccorect then the whole system is compromised. 

- DataUtilities:
    - Arrays are a basic form a data structures that are crucial to the calculation and transfer of information, especially in regards to tables and graphing. In order to ensure that the output of these graphs and charts are correct the data from their base datasets must both provide the correct output, as well as throw the correct exceptions when needed. 

Limitatons and Concerns: 
Thhe main limitation that we must plan around is the fact that we are doing black box testing, meaning we have no access to the code. During the creation and execution fo the JUnit tests we have to trust that the requirements outlines in the documentation are met by the current code. As a result, our testing should cover every single possible input and output for a single function. Even if one scenario of input works or doesnt that doesn not mean that there is not some hidden implementation or logic that could possibly cause either failiure or success. 

Schedule:
| Task                | Start Date  | End Date    |
|---------------------|-------------|-------------|
| Test Case Planning  | Fri, Feb 9  | Fri, Feb 9  |
| JUnit Creation      | Fri, Feb 9  | Mon, Feb 13 |
| Finish Lab Report   | Thrs, Feb 8 | We, Feb 14  |

# 3 Test cases developed

Range:
  - We first look at the possible edge case ranges along with the normal operating ranges, with 10 different cases. We then take each of these 10 cases and test our five selected methods against these ranges. For each test case (small, big, negative, positive) we will create one test method for each of the selected methods from the range class. Each test case will have their own test class and use the same range within that test case for all five test methods. The functon being tested will made clear by the names given.

Partitions:
  - These methods moslty deal with legal input, this is becasue the constructor and other methods already check for the valid initalization. However that does not mean we cannot use unusual and specific values to test for the correctness of these functions. Since the parameters are also double, we can test with integer numbers and float numbers. However keeping in mind that the Range class constructor already provides type checking and rejects a range with anything other than double or legal lower and upper bounds, there is no way to test illegal inputs for these functions. 

| Test Case Class     | Test Methods Names                                                                                      | Range
|---------------------|---------------------------------------------------------------------------------------------------------|---------
| GetCentralValueTest | GetCentralValue_PositiveRange, GetCentralValue_NegativeRange, GetCentralValue_OppositeRange,            |
|    Nicole           | GetCentralValue_ZeroPositiveRange, GetCentralValue_ZeroNegativeRange, GetCentralValue_BothZero,         |
|                     | GetCentralValue_EqualNegative, GetCentralValue_EqualPositive, GetCentralValue_LargeRange,               |
|                     | GetCentralValue_SmallRange                                                                              |
| GetLengthTest       | GetLength_PositiveRange, GetLength_NegativeRange, GetLength_OppositeRange, GetLength_ZeroPositiveRange, |
|     Nelson          | GetLength_ZeroNegativeRange, GetLength_BothZero, GetLength_EqualNegative, GetLength_EqualPositive,      |
|                     | GetLength_LargeRange, GetLength_SmallRange                                                              |
| GetLowerBoundTest   | GetLowerBound_PositiveRange, GetLowerBound_NegativeRange, GetLowerBound_OppositeRange,                  |
|     Nelson          | GetLowerBound_ZeroPositiverange, GetLowerBound_ZeroNegativeRange, GetLowerBound_BothZero,               |
|                     | GetLowerBound_EqualNegative, GetLowerBound_EqualPositive, GetLowerBound_LargeRange,                     |
|                     | GetLowerBound_SmallRange                                                                                |
| GetUpperBoundTest   | GetUpperBound_PositiveRange, GetLowerBound_NegativeRange, GetLowerBound_OppositeRange,                  |
|     Nelson          | GetLowerBound_ZeroPositiveRange, GetLowerBound_ZeroNegativeRange, GetLowerBound_BothZero                |
|                     | GetLowerBound_EqualNegative, GetLowerBound_EqualPositive, GetLowerBound_LargeRange,                     |
|                     | GetLowerBound_SmallRange                                                                                |
| ToStringTest        | ToString_PositiveRange, ToString_NegativeRange, ToString_OppositeRange, ToString_ZeroPositiveRange,     |   
|    Nicole           | ToString_ZeroNegativeRange, ToString_BothZero, ToString_EqualNegative, ToString_EqualPositive,          |
|                     | ToString_LargeRange, ToString_SmallRange                                                                |

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

All work was completed and dsscussed as a group, due to all files being availible on github all members were able to contribute to the report. The testing plans themsevles were all carefully researched and disscussed before hand, and its implementation was done with all members present on one computer. Mmebers were split into pairs for efficiency. A pair of two was assigned a class to write tests for, within those groups the work would be divided with one member taking on more classes while the other made up for it in documentation in the lab-report. At the end all four members came together for the final review and implementation into a whole program.

# 5 Difficulties encountered, challenges overcome, and lessons learned

There were some difficulties with the panning and design of the test cases themselves, since very few of us have made our own JUnit test to this scale. Ensuring that we had tests that met the requirements in the handout took some time to disscuss and deliberate on. The biggest lesson that we took from this lab is the intricacies and time that it takes to properly execute JUnit cases, it is important to understand that these test cases should do their best to cover all kinds of inputs and functions 

# 6 Comments/feedback on the lab itself

We feel like this was a good lab that demonstrated the usefulness and ease at which JUnit can be used, even with code you did not have access to. JUnit is a pretty simple tool to use, the only issues is just the design phase can be difficult if some requirements are not fully undertsood. The freedom to choose which functions to create tests for in Range provided a little more freedom for use to explore and come up with out own ideas. However, the DataUtilities functions being already chosen did also give us a challenge to overcome. 
